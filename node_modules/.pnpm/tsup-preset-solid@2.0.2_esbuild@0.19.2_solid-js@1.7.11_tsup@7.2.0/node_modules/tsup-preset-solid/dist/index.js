// src/preset.ts
import path from "path";
import { solidPlugin } from "esbuild-plugin-solid";
var asArray = (value) => Array.isArray(value) ? value : [value];
function parsePresetOptions(preset_options, watching = false) {
  const entries = asArray(preset_options.entries);
  const with_cjs = !!preset_options.cjs;
  const out_dir = "./dist/";
  const single_entry = entries.length === 1;
  const getExport = single_entry ? (_, exportname) => exportname : (filename, exportname) => `${filename}/${exportname}`;
  const parsed_entries = entries.map((options) => {
    const filename = options.name ?? path.basename(path.normalize(options.entry)).split(".")[0];
    const exports = {
      main: getExport(filename, "index"),
      dev: getExport(filename, "dev"),
      server: getExport(filename, "server")
    };
    return {
      options,
      filename,
      exports,
      paths: {
        main: out_dir + exports.main,
        dev: out_dir + exports.dev,
        server: out_dir + exports.server
      },
      type: {
        dev: !!options.dev_entry,
        server: !!options.server_entry,
        jsx: options.entry.endsWith(".jsx") || options.entry.endsWith(".tsx")
      }
    };
  });
  parsed_entries.sort((a, b) => {
    if (a.filename === "index")
      return -1;
    if (b.filename === "index")
      return 1;
    return a.filename.localeCompare(b.filename);
  });
  return {
    watching,
    format: with_cjs ? ["esm", "cjs"] : "esm",
    cjs: with_cjs,
    out_dir,
    modify_esbuild_options: preset_options.modify_esbuild_options ?? ((x) => x),
    esbuild_plugins: preset_options.esbuild_plugins ?? [],
    entries: parsed_entries,
    index_entry: parsed_entries.find((p) => p.filename === "index") ?? parsed_entries[0],
    drop_console: !!preset_options.drop_console,
    single_entry
  };
}
function generateTsupOptions(options) {
  const items = [];
  for (const entry of options.entries) {
    for (const dev of [false, entry.type.dev]) {
      for (const server of [false, entry.type.server]) {
        if (dev && server)
          continue;
        for (const jsx of [false, entry.type.jsx]) {
          const item = items.find(
            (p) => p.type.dev === dev && p.type.server === server && p.type.jsx === jsx
          );
          if (item) {
            item.entries.add(entry);
          } else {
            items.push({ type: { dev, server, jsx }, entries: /* @__PURE__ */ new Set([entry]) });
          }
        }
      }
    }
  }
  return items.map((item, i) => {
    const { type, entries } = item;
    const is_main = !type.dev && !type.jsx && !type.server;
    const tsup_entry = {};
    for (const entry of entries) {
      tsup_entry[type.dev ? entry.exports.dev : type.server ? entry.exports.server : entry.exports.main] = type.dev && typeof entry.options.dev_entry === "string" ? entry.options.dev_entry : type.server && typeof entry.options.server_entry === "string" ? entry.options.server_entry : entry.options.entry;
    }
    return {
      target: "esnext",
      platform: type.server ? "node" : "browser",
      format: options.watching || type.jsx ? "esm" : options.format,
      clean: !options.watching && i === 0,
      dts: is_main ? true : void 0,
      entry: tsup_entry,
      treeshake: options.watching ? false : { preset: "safest" },
      replaceNodeEnv: true,
      esbuildOptions(esOptions) {
        esOptions.define = {
          ...esOptions.define,
          "process.env.NODE_ENV": type.dev ? `"development"` : `"production"`,
          "process.env.PROD": type.dev ? "false" : "true",
          "process.env.DEV": type.dev ? "true" : "false",
          "process.env.SSR": type.server ? "true" : "false",
          "import.meta.env.NODE_ENV": type.dev ? `"development"` : `"production"`,
          "import.meta.env.PROD": type.dev ? "false" : "true",
          "import.meta.env.DEV": type.dev ? "true" : "false",
          "import.meta.env.SSR": type.server ? "true" : "false"
        };
        esOptions.jsx = "preserve";
        esOptions.chunkNames = "[name]/[hash]";
        if (!type.dev && options.drop_console)
          esOptions.drop = ["console", "debugger"];
        return options.modify_esbuild_options(esOptions, item);
      },
      outExtension({ format }) {
        if (format === "esm" && type.jsx)
          return { js: ".jsx" };
        return {};
      },
      esbuildPlugins: !type.jsx ? [
        solidPlugin({ solid: { generate: type.server ? "ssr" : "dom" } }),
        ...options.esbuild_plugins
      ] : options.esbuild_plugins
    };
  });
}

// src/package-json.ts
import fsp from "fs/promises";
import path2 from "path";
var getImportConditions = (options, entry, file_type) => ({
  import: {
    types: entry.paths.main + ".d.ts",
    default: entry.paths[file_type] + ".js"
  },
  require: options.cjs ? {
    types: entry.paths.main + ".d.cts",
    default: entry.paths[file_type] + ".cjs"
  } : void 0
});
var getConditions = (options, entry, type) => {
  const add_dev = entry.type.dev && type === "main";
  return {
    solid: entry.type.jsx ? add_dev ? {
      development: `${entry.paths.dev}.jsx`,
      import: `${entry.paths[type]}.jsx`
    } : `${entry.paths[type]}.jsx` : void 0,
    development: add_dev ? getImportConditions(options, entry, "dev") : void 0,
    ...getImportConditions(options, entry, type)
  };
};
function generatePackageExports(options) {
  const types_versions = {};
  const browser = {};
  const package_json = {
    main: "",
    module: "",
    types: "",
    browser,
    exports: {},
    typesVersions: options.single_entry ? {} : { "*": types_versions }
  };
  for (const entry of options.entries) {
    if (entry === options.index_entry) {
      package_json.main = `${entry.type.server ? entry.paths.server : entry.paths.main}.${options.cjs ? "cjs" : "js"}`;
      package_json.module = `${entry.type.server ? entry.paths.server : entry.paths.main}.js`;
      package_json.types = entry.paths.main + ".d.ts";
    }
    if (entry.type.server) {
      browser[entry.paths.server + ".js"] = entry.paths.main + ".js";
      if (options.cjs)
        browser[entry.paths.server + ".cjs"] = entry.paths.main + ".cjs";
    }
    const conditions = {
      ...entry.type.server && {
        worker: getConditions(options, entry, "server"),
        browser: getConditions(options, entry, "main"),
        deno: getConditions(options, entry, "server"),
        node: getConditions(options, entry, "server")
      },
      ...getConditions(options, entry, "main")
    };
    if (options.single_entry) {
      package_json.exports = conditions;
    } else if (entry.filename === "index") {
      package_json.exports["."] = conditions;
    } else {
      package_json.exports[`./${entry.filename}`] = conditions;
      types_versions[entry.filename] = [entry.paths.main + ".d.ts"];
    }
  }
  return package_json;
}
var CWD = process.cwd();
var DEFAULT_PKG_PATH = path2.join(CWD, "package.json");
var asWarning = (message) => `\x1B[33m${message}\x1B[0m`;
async function writePackageJson(fields, filename = DEFAULT_PKG_PATH, space) {
  const buffer = await fsp.readFile(filename, "utf-8");
  const pkg = JSON.parse(buffer);
  const newPkg = { ...pkg, ...fields };
  if (newPkg["type"] !== "module") {
    newPkg["type"] = "module";
    console.log(
      asWarning(
        `
Warning: package.json type field was not set to "module". This preset requires packages to be esm first. Setting it to "module".
`
      )
    );
  }
  if (space === void 0) {
    const first_indent = buffer.indexOf("\n") + 1;
    for (let i = first_indent; i < buffer.length; i++) {
      if (buffer[i] !== " " && buffer[i] !== "	") {
        space = buffer.slice(first_indent, i);
        break;
      }
    }
  }
  await fsp.writeFile(filename, JSON.stringify(newPkg, null, space) + "\n", "utf-8");
}
export {
  CWD,
  DEFAULT_PKG_PATH,
  generatePackageExports,
  generateTsupOptions,
  getConditions,
  getImportConditions,
  parsePresetOptions,
  writePackageJson
};
